# ADR-003: Technical Standards and Conventions

## Status
Accepted

## Context
To maintain consistency and quality across AtlasPress X, we need clear technical standards for code, testing, and development practices.

## Decision

### TypeScript Standards
- **Strict Mode**: All projects use `strict: true` in tsconfig.json
- **Path Mapping**: Use absolute imports with `@/` prefix
- **Type Coverage**: Minimum 95% type coverage required
- **No `any`**: Use `unknown` or proper typing instead

### Code Style
- **Formatter**: Prettier with 2-space indentation
- **Linter**: ESLint with TypeScript rules
- **Naming**: 
  - Components: PascalCase
  - Functions/Variables: camelCase
  - Constants: UPPER_SNAKE_CASE
  - Files: kebab-case
- **Imports**: Grouped and sorted (external → internal → relative)

### React Standards
- **Components**: Functional components with hooks
- **Props**: TypeScript interfaces with JSDoc comments
- **State**: Prefer `useState` for simple state, `useReducer` for complex
- **Effects**: Minimal `useEffect` usage, proper dependency arrays
- **Performance**: `React.memo`, `useMemo`, `useCallback` where beneficial

### Database Standards
- **Naming**: snake_case for tables and columns
- **Primary Keys**: UUID strings (`id`)
- **Timestamps**: `createdAt`, `updatedAt` on all tables
- **Soft Deletes**: `deletedAt` for audit trails
- **Indexes**: Strategic indexing for query performance

### API Standards
- **REST**: RESTful conventions for HTTP methods
- **Responses**: Consistent JSON structure with `data`, `error`, `meta`
- **Status Codes**: Proper HTTP status codes
- **Validation**: Zod schemas for request/response validation
- **Documentation**: OpenAPI/Swagger specs

### Testing Standards
- **Unit Tests**: Vitest with 80% minimum coverage
- **Integration Tests**: Database and API integration
- **E2E Tests**: Playwright for critical user journeys
- **Test Data**: Factories for consistent test data
- **Mocking**: Minimal mocking, prefer real implementations

### Security Standards
- **Authentication**: Auth.js with secure session management
- **Authorization**: RBAC with permission-based checks
- **Input Validation**: Zod schemas for all inputs
- **SQL Injection**: Prisma ORM protection
- **XSS Protection**: React's built-in protection + CSP headers
- **CSRF Protection**: Auth.js CSRF tokens

### Performance Standards
- **Bundle Size**: Code splitting and lazy loading
- **Images**: Next.js Image optimization with WebP/AVIF
- **Caching**: Redis for frequently accessed data
- **Database**: Query optimization and connection pooling
- **Monitoring**: Sentry for errors, Web Vitals for performance

### File Structure Conventions
```
src/
├── app/                 # Next.js App Router
│   ├── (auth)/         # Route groups
│   ├── (dashboard)/    # Authenticated routes
│   ├── api/            # API routes
│   └── globals.css     # Global styles
├── components/         # Reusable components
│   ├── ui/            # Base UI components
│   ├── forms/         # Form components
│   └── layout/        # Layout components
├── lib/               # Utilities and configurations
│   ├── auth/          # Auth configuration
│   ├── db/            # Database setup
│   ├── validations/   # Zod schemas
│   └── utils/         # Helper functions
├── types/             # TypeScript type definitions
├── hooks/             # Custom React hooks
└── styles/            # Global styles and themes
```

### Environment Configuration
- **Development**: `.env.local`
- **Testing**: `.env.test`
- **Production**: `.env.production`
- **Validation**: Zod schemas for environment variables
- **Secrets**: Never commit, use proper secret management

### Git Workflow
- **Branching**: Feature branches from `main`
- **Commits**: Conventional commits (`feat:`, `fix:`, `docs:`, etc.)
- **PRs**: Required for all changes with automated checks
- **Releases**: Semantic versioning with changelog

## Consequences
### Positive
- Consistent codebase across all developers
- Improved maintainability and onboarding
- Automated quality gates
- Clear expectations for contributions

### Considerations
- Initial setup complexity
- Learning curve for new team members
- Potential over-engineering for simple features

## Enforcement
- Pre-commit hooks for linting and formatting
- CI/CD pipeline checks for all standards
- Code review checklist
- Regular technical debt reviews
